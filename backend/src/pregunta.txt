// No jala el clave video

import { PreguntaEjercicioModel } from "../models/preguntaModel.js";
import { ActividadController } from "./actividadController.js";

export class PreguntaEjercicioController {

  // Funcion para crear una nueva pregunta de ejercicio
  // Primero obtenemos el ID de la actividad desde los parámetros de la solicitud
  // Obtener datos de la solicitud (pregunta, multimedia, consejo, claveVideo, opciones)
  // Crear la pregunta de ejercicio usando el modelo
  // Hicimos la actualización más dinámica no necesita ingresar todos los campos el usuario
  static async create(req, res) {
    try {
      const actividadId = parseInt(req.params.actividadId);
      const multimedia = req.file ? req.file.buffer : undefined;
      const { pregunta, consejo, claveVideo, opciones } = req.body;
      const opcion = JSON.parse(opciones);

      const preguntaEjercicio = await PreguntaEjercicioModel.create(
        actividadId,
        pregunta,
        multimedia,
        consejo,
        claveVideo,
        opcion
      );

      res.json({
        mensaje: 'Pregunta de ejercicio creada con éxito',
        preguntaEjercicio,
      });
    } catch (error) {
      console.error('Error al crear la pregunta de ejercicio:', error);
      res.status(500).json({ mensaje: 'Error interno del servidor' });
    }
  }

  // Obtener una pregunta de ejercicio específica por su ID
  // Obtenemos el ID de la pregunta del ejercicio con los parametros de la pregunta
  // Obtener la pregunta de ejercicio usando el modelo
  static async getById(req, res) {
    try {
      const preguntaEjercicioId = parseInt(req.params.idPreguntaEjercicio);
      const preguntaEjercicio = await PreguntaEjercicioModel.getById(preguntaEjercicioId);
      res.json(preguntaEjercicio);
    } catch (error) {
      console.error('Error al obtener la pregunta de ejercicio:', error);
      res.status(500).json({ mensaje: 'Error interno del servidor' });
    }
  }

  // Actualizar una pregunta de ejercicio existente
  // Obtenemos su  ID de la pregunta de ejercicio desde el Model
  // Obtenemos los nuevos datos de la pregunta y el opciones del ejercicio desde la solicitud
  // Actualizamos todo

  static async update(req, res) {
    try {
      const preguntaEjercicioId = parseInt(req.params.idPreguntaEjercicio);
      const { pregunta, multimedia, consejo, claveVideo, opciones } = req.body;

      // Obtener la pregunta de ejercicio existente
      const preguntaEjercicioExistente = await PreguntaEjercicioModel.getById(
        preguntaEjercicioId
      );

      // Verificar si se proporciona un nuevo archivo multimedia
      const nuevaMultimedia = multimedia || preguntaEjercicioExistente.multimedia;

      // Actualizar la pregunta de ejercicio
      const preguntaEjercicioActualizada = await PreguntaEjercicioModel.update(
        preguntaEjercicioId,
        {
          pregunta,
          multimedia: nuevaMultimedia,
          consejo,
          claveVideo: claveVideo !== undefined ? claveVideo : null, // Asignar null solo si se proporciona un valor
          opciones,
        }
      );

      res.json({
        mensaje: 'Pregunta de ejercicio actualizada con éxito',
        preguntaEjercicio: preguntaEjercicioActualizada,
      });
    } catch (error) {
      console.error('Error al actualizar la pregunta de ejercicio:', error);
      res.status(500).json({ mensaje: 'Error interno del servidor' });
    }
  }

  // Eliminar una pregunta de ejercicio existente
  // Obtener el ID de la pregunta de ejercicio desde los parámetros de la solicitud
  // Eliminar la pregunta de ejercicio usando el modelo

  static async delete(req, res) {
    try {
      const preguntaEjercicioId = parseInt(req.params.idPreguntaEjercicio);
      const preguntaEjercicioEliminada = await PreguntaEjercicioModel.delete(preguntaEjercicioId);
      res.json({ mensaje: 'Pregunta de ejercicio eliminada con éxito', preguntaEjercicio: preguntaEjercicioEliminada });
    } catch (error) {
      console.error('Error al eliminar la pregunta de ejercicio:', error);
      res.status(500).json({ mensaje: 'Error interno del servidor' });
    }
  }

  // Funciones para verificar si la pregunta de ejercicio existe y si tiene un ID de actividad asociado.
  // Se obtiene primero el ID de la pregunta de ejercicio 
  // Si existe, se utiliza el controlador de Actividad para obtener la actividad asociada.
  // Si no tiene nada asociado se responde con el error 404 indicando que no se encontró ni madres

  static async getActividadByPreguntaEjercicio(req, res) {
    try {
      const preguntaEjercicioId = parseInt(req.params.idPreguntaEjercicio);
      const preguntaEjercicio = await PreguntaEjercicioModel.getById(preguntaEjercicioId);
      if (preguntaEjercicio && preguntaEjercicio.actividadId) {
        const actividad = await ActividadController.getById(preguntaEjercicio.actividadId);
        res.json(actividad);
      } else {
        res.status(404).json({ mensaje: 'Pregunta de ejercicio no encontrada o sin actividad asociada' });
      }
    } catch (error) {
      console.error('Error al obtener la actividad asociada a la pregunta de ejercicio:', error);
      res.status(500).json({ mensaje: 'Error interno del servidor' });
    }
  }
}


// Model 

import { prisma } from "../conexion.js";

export class PreguntaEjercicioModel {

   //Aqui combine los model de PreguntaEjercio y OpcionEjercicio, con su relacion con Actividad 
   //Funcion para crear la Pregunta y las opciones
   static create = async (actividadId, pregunta, multimedia, consejo, claveVideo, opcion) => {
      const preguntaEjercicio = await prisma.preguntaEjercicio.create({
         data: {
            Actividad: { connect: { id: actividadId } },
            pregunta: pregunta,
            multimedia: multimedia,
            consejo: consejo,
            ClaveVideo: claveVideo !== undefined ? claveVideo : null,
            OpcionEjercicio: {
               create: {
                  a: opcion.a,
                  b: opcion.b,
                  c: opcion.c,
                  r1: opcion.r1,
                  r2: opcion.r2,
               }
            }
         },
      });
      return preguntaEjercicio;
   }

   static getById = async (preguntaEjercicioId) => {
      const preguntaEjercicio = await prisma.preguntaEjercicio.findUnique({
         where: { id: preguntaEjercicioId },
         include: {
            OpcionEjercicio: true,
         },
      });
      return preguntaEjercicio;
   }

   //Actualizar informacion de la Pregunta y sus Opciones
   static update = async (preguntaEjercicioId, nuevaInformacion) => {
      const preguntaEjercicioActualizada = await prisma.preguntaEjercicio.update({
         where: { id: preguntaEjercicioId },
         data: {
            pregunta: nuevaInformacion.pregunta,
            multimedia: nuevaInformacion.multimedia,
            consejo: nuevaInformacion.consejo,
            claveVideo: nuevaInformacion.claveVideo,
            OpcionEjercicio: {
               update: nuevaInformacion.opciones.map((opcion) => ({
                  where: { id: opcion.id },
                  data: {
                     a: opcion.a,
                     b: opcion.b,
                     c: opcion.c,
                     r1: opcion.r1,
                     r2: opcion.r2,
                  },
               })),
            },
         },
         include: {
            OpcionEjercicio: true,
         },
      });
      return preguntaEjercicioActualizada;
   }

   static delete = async (preguntaEjercicioId) => {
      const preguntaEjercicioEliminada = await prisma.preguntaEjercicio.delete({
         where: { id: preguntaEjercicioId },
         include: {
            OpcionEjercicio: true,
         },
      });
      return preguntaEjercicioEliminada;
   }
}
