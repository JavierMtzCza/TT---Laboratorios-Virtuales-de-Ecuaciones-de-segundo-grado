Routes

import express from "express";
import { resetpasswordController } from "../controllers/resetpasswordController.js";

const router = express.Router();

router.post("/resetpassword", resetpasswordController);

export default router;



controllers

import nodemailer from "nodemailer";
import bcrypt from 'bcrypt';
import { CambioContrasenaModel } from "../models/resetpasswordModel.js";

export const resetpasswordController = async (req, res) => {
  const { correo } = req.body;

  const usuario = await usuarioModel.getByEmail(correo);
  if (!usuario) {
    return res.status(400).json({ error: "Correo electrónico no válido" });
  }

  const codigoVerificacion = Math.random().toString(36).slice(2, 5);
  const codigoVerificacionCifrado = await bcrypt.hash(codigoVerificacion, 10);

  const transport = nodemailer.createTransport({
    service: "gmail",
    auth: {
      user: "ikinnegameplays@gmail.com", // Cambiar por tu usuario de Gmail
      pass: " ", // Cambiar por tu contraseña de Gmail
    },
  });

  await transport.sendMail({
    to: correo,
    subject: "Código de verificación",
    text: `Su código de verificación es: ${codigoVerificacion}`,
  });

  await CambioContrasenaModel.create({ correo }); // Crear la solicitud de cambio de contraseña

  res.json({ message: "Se ha enviado un código de verificación a su correo electrónico." });
};


//Middleware

import { CambioContrasenaModel } from "../models/resetpasswordModel.js";

function verifyResetPasswordCode(req, res, next) {
  const { correo, codigoVerificacion } = req.body;

  const cambioContrasena = CambioContrasenaModel.verifyCode(correo, codigoVerificacion);

  if (!cambioContrasena) {
    res.status(403).json({ error: "Código de verificación no válido" });
    return;
  }

  next();
}

module.exports = verifyResetPasswordCode;


// models
import { prisma } from "../conexion.js";
import bcrypt from 'bcrypt';

export class CambioContrasenaModel {
  // Consultar código de verificación por correo
  static getCode = async (correoUsuario) => {
    const cambioContrasena = await prisma.cambioContrasena.findUnique({
      where: { usuarioCorreo: correoUsuario },
    })
    return cambioContrasena;
  }

  // Crear solicitud de cambio de contraseña con código hasheado
  static create = async (datos) => {
    const codigo = generarCodigoVerificacion(); // Generar un código de verificación aleatorio
    const fechaCaducidad = new Date(Date.now() + (60 * 1000 * 10)); // Establecer la fecha de caducidad a 10 minutos

    const codigoHasheado = await bcrypt.hash(codigo, 10); // Hashear el código antes de guardarlo

    const cambioContrasena = prisma.cambioContrasena.create({
      data: {
        codigo: codigoHasheado,
        fechaCaducidad,
        estado: true, // Establecer el estado como verdadero
        usuarioCorreo: datos.correo,
      }
    })
    return cambioContrasena;
  }

  // Comprobar código de verificación y estado
  static verifyCode = async (correoUsuario, codigoVerificacion) => {
    const cambioContrasena = await prisma.cambioContrasena.findUnique({
      where: {
        usuarioCorreo: correoUsuario,
      },
    })

    if (!cambioContrasena || !cambioContrasena.estado) {
      return null; // Si el código no existe o el estado no es verdadero, retornar nulo
    }

    const codigoValido = await bcrypt.compare(codigoVerificacion, cambioContrasena.codigo); // Comparar el código ingresado con el hasheado

    if (codigoValido) {
      return cambioContrasena; // Retornar el registro si el código es válido
    }

    return null;
  }

  // Actualizar contraseña y establecer estado a falso
  static updatePassword = async (correoUsuario, nuevaContrasena) => {
    const saltGenerado = await bcrypt.genSalt(10); // Generar un salt aleatorio
    nuevaContrasena = await bcrypt.hash(nuevaContrasena, saltGenerado); // Hashear la nueva contraseña usando el salt

    const usuario = prisma.usuario.update({
      where: { correo: correoUsuario },
      data: { contrasena: nuevaContrasena },
    })

    // Invalidar el código de verificación una vez actualizada la contraseña
    await prisma.cambioContrasena.update({
      where: { usuarioCorreo: correoUsuario },
      data: { estado: false },
    })

    return usuario;
  }
}



//PreguntacuesModel.js 

import { prisma } from "../conexion.js";

export class PreguntaCuesModel {
  constructor(data) {
    this.id = data.id;
    this.pregunta = data.pregunta;
    this.multimedia = data.multimedia;
    this.actividadId = data.actividadId;
  }

  static async create(data) {
    const pregunta = await prisma.preguntaCuestionario.create({
      data: {
        pregunta: data.pregunta,
        multimedia: data.multimedia,
        Actividad: {
          connect: { id: data.actividadId }, 
        },
      },
    });

    return pregunta;
  }

  static async findById(id) {
    const pregunta = await prisma.preguntaCuestionario.findUnique({
      where: {
        id,
      },
      include: {
        Actividad: true,
      },
    });

    return pregunta;
  }

  static async findAll() {
    const preguntas = await prisma.preguntaCuestionario.findMany();

    return preguntas;
  }

  static async createCuestionarioConFechaLimite(data) {
    const { pregunta, multimedia, actividadId, fechaLimite } = data;

    const cuestionario = await prisma.preguntaCuestionario.create({
      data: {
        pregunta,
        multimedia,
        fechaLimite,
        Actividad: {
          connect: { id: actividadId },
        },
      },
    });

    return cuestionario;
  }
}




import { PreguntaEjercicioModel } from "../models/preguntaModel.js";
import { ActividadController } from "./actividadController.js";

export class PreguntaEjercicioController {

  // Funcion para crear una nueva pregunta de ejercicio
   // Primero obtenemos el ID de la actividad desde los parámetros de la solicitud
    // Obtener datos de la solicitud (pregunta, multimedia, consejo, claveVideo,opciones)
    // Crear la pregunta de ejercicio usando el modelo
   static async create(req, res) {
      try {
         const actividadId = parseInt(req.params.actividadId);
         const { pregunta, multimedia, consejo, claveVideo, opciones } = req.body;
         const preguntaEjercicio = await PreguntaEjercicioModel.create(actividadId, pregunta, multimedia, consejo, claveVideo, opciones);
         res.json({ mensaje: 'Pregunta de ejercicio creada con éxito', preguntaEjercicio });
      } catch (error) {
         console.error('Error al crear la pregunta de ejercicio:', error);
         res.status(500).json({ mensaje: 'No existe una activdad creada con ese ID' });
      }
   }

  // Obtener una pregunta de ejercicio específica por su ID
   // Obtenemos el ID de la pregunta del ejercicio con los parametros de la pregunta
    // Obtener la pregunta de ejercicio usando el modelo
   static async getById(req, res) {
      try {
         const preguntaEjercicioId = parseInt(req.params.idPreguntaEjercicio);
         const preguntaEjercicio = await PreguntaEjercicioModel.getById(preguntaEjercicioId);
         res.json(preguntaEjercicio);
      } catch (error) {
         console.error('Error al obtener la pregunta de ejercicio:', error);
         res.status(500).json({ mensaje: 'Error interno del servidor' });
      }
   }

   // Actualizar una pregunta de ejercicio existente
    // Obtenemos su  ID de la pregunta de ejercicio desde el Model
    // Obtenemos los nuevos datos de la pregunta y el opciones del ejercicio desde la solicitud
    // Actualizamos todo

   static async update(req, res) {
      try {
         const preguntaEjercicioId = parseInt(req.params.idPreguntaEjercicio);
         const { pregunta, multimedia, consejo, claveVideo, opciones } = req.body;
         const preguntaEjercicioActualizada = await PreguntaEjercicioModel.update(preguntaEjercicioId, { pregunta, multimedia, consejo, claveVideo, opciones });
         res.json({ mensaje: 'Pregunta de ejercicio actualizada con éxito', preguntaEjercicio: preguntaEjercicioActualizada });
      } catch (error) {
         console.error('Error al actualizar la pregunta de ejercicio:', error);
         res.status(500).json({ mensaje: 'Error interno del servidor' });
      }
   }

   // Eliminar una pregunta de ejercicio existente
   // Obtener el ID de la pregunta de ejercicio desde los parámetros de la solicitud
   // Eliminar la pregunta de ejercicio usando el modelo

   static async delete(req, res) {
      try {
         const preguntaEjercicioId = parseInt(req.params.idPreguntaEjercicio);
         const preguntaEjercicioEliminada = await PreguntaEjercicioModel.delete(preguntaEjercicioId);
         res.json({ mensaje: 'Pregunta de ejercicio eliminada con éxito', preguntaEjercicio: preguntaEjercicioEliminada });
      } catch (error) {
         console.error('Error al eliminar la pregunta de ejercicio:', error);
         res.status(500).json({ mensaje: 'Error interno del servidor' });
      }
   }


   //Se obtiene el ID de la pregunta de ejercicio 
//Funciones para verificar si la pregunta de ejercicio existe y si tiene un ID de actividad asociado.
//Si existe, se utiliza el controlador de Actividad para obtener la actividad asociada.
 //Si no tiene nada asociado se responde con el error 404 indicando que no se encontró 
 //ni pregunta o actividad 
 
   static async getActividadByPreguntaEjercicio(req, res) {
      try {
         const preguntaEjercicioId = parseInt(req.params.idPreguntaEjercicio);
         const preguntaEjercicio = await PreguntaEjercicioModel.getById(preguntaEjercicioId);
         if (preguntaEjercicio && preguntaEjercicio.actividadId) {
            const actividad = await ActividadController.getById(preguntaEjercicio.actividadId);
            res.json(actividad);
         } else {
            res.status(404).json({ mensaje: 'Pregunta de ejercicio no encontrada o sin actividad asociada' });
         }
      } catch (error) {
         console.error('Error al obtener la actividad asociada a la pregunta de ejercicio:', error);
         res.status(500).json({ mensaje: 'Error interno del servidor' });
      }
   }
}
