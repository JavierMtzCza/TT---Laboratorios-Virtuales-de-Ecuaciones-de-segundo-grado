// Código para desactivar todas las opciones y solo dejar una como correcta 

// opcionCuestionarioModel.js
import { prisma } from "../conexion.js";

export class OpcionCuestionarioModel {
  // Crear Opción de Cuestionario
  static create = async (preguntaCuestionarioId, textOpcion, multimedia, correcta) => {
    const opcionCuestionario = await prisma.opcionCuestionario.create({
      data: {
        preguntaCuestionarioId: preguntaCuestionarioId,
        textOpcion: textOpcion,
        multimedia: multimedia,
        correcta: correcta,
      },
      include: {
        PreguntaCuestionario: true,
      },
    });
    return opcionCuestionario;
  };
  

  // Obtener Opción de Cuestionario por ID
  static getById = async (opcionCuestionarioId) => {
    const opcionCuestionario = await prisma.opcionCuestionario.findUnique({
      where: { id: opcionCuestionarioId },
      include: {
        PreguntaCuestionario: true,
      },
    });
    return opcionCuestionario;
  };

  // Actualizar Opción de Cuestionario
  static update = async (opcionCuestionarioId, nuevaInformacion) => {
    const opcionCuestionarioActualizada = await prisma.opcionCuestionario.update({
      where: { id: opcionCuestionarioId },
      data: nuevaInformacion,
      include: {
        PreguntaCuestionario: true,
      },
    });
    return opcionCuestionarioActualizada;
  };

  // Eliminar Opción de Cuestionario por ID
  static delete = async (opcionCuestionarioId) => {
    const opcionCuestionarioEliminada = await prisma.opcionCuestionario.delete({
      where: { id: opcionCuestionarioId },
      include: {
        PreguntaCuestionario: true,
      },
    });
    return opcionCuestionarioEliminada;
  };

  // Obtener todas las opciones asociadas a una pregunta
  static getAllByPregunta = async (preguntaCuestionarioId) => {
    const opciones = await prisma.opcionCuestionario.findMany({
      where: {
        preguntaCuestionarioId: preguntaCuestionarioId,
      },
    });
    return opciones;
  };

  // Actualizar Opción de Cuestionario y desactivar otras opciones como correctas
  static updateAndDeactivateOthers = async (opcionCuestionarioId, nuevaInformacion) => {
    const opcionCuestionarioActualizada = await prisma.opcionCuestionario.update({
      where: { id: opcionCuestionarioId },
      data: nuevaInformacion,
      include: {
        PreguntaCuestionario: true,
      },
    });

    // Desactivar otras opciones como correctas
    if (nuevaInformacion.correcta) {
      await prisma.opcionCuestionario.updateMany({
        where: {
          preguntaCuestionarioId: opcionCuestionarioActualizada.PreguntaCuestionario.id,
          id: { not: opcionCuestionarioId },
        },
        data: {
          correcta: false,
        },
      });
    }

    return opcionCuestionarioActualizada;
  };
}


// Controller 

import { OpcionCuestionarioModel } from "../models/opcioncuesModel.js";

export class OpcionCuestionarioController {
  static async create(req, res) {
    try {
      const preguntaCuestionarioId = parseInt(req.params.preguntaCuestionarioId);
      const multimedia = req.file ? req.file.buffer : undefined; // Verificar si hay un nuevo archivo
      const { textOpcion, correcta } = req.body;

      // Convertir correcta a booleano
      const correctaBoolean = correcta === "true" ? true : false;

      const opcionCuestionario = await OpcionCuestionarioModel.create(
        preguntaCuestionarioId,
        textOpcion,
        multimedia,
        correctaBoolean
      );

      res.json({
        mensaje: 'Opción de cuestionario creada con éxito',
        opcionCuestionario,
      });
    } catch (error) {
      console.error('Error al crear la opción de cuestionario:', error);
      res.status(500).json({ mensaje: 'Error interno del servidor' });
    }
  }

  static async getById(req, res) {
    try {
      const opcionCuestionarioId = parseInt(req.params.opcionCuestionarioId);
      const opcionCuestionario = await OpcionCuestionarioModel.getById(opcionCuestionarioId);
      res.json(opcionCuestionario);
    } catch (error) {
      console.error('Error al obtener la opción de cuestionario:', error);
      res.status(500).json({ mensaje: 'Error interno del servidor' });
    }
  }

  static async update(req, res) {
    try {
      const opcionCuestionarioId = parseInt(req.params.opcionCuestionarioId);
      const { textOpcion, correcta } = req.body;
      const multimedia = req.file ? req.file.buffer : undefined;

      // Convertir correcta a booleano
      const correctaBoolean = correcta === "true" ? true : false;

      // Obtener la opción de cuestionario antes de la actualización
      const opcionCuestionarioExistente = await OpcionCuestionarioModel.getById(opcionCuestionarioId);

      // Construir un objeto con los campos proporcionados
      const datosActualizados = {};
      if (textOpcion) datosActualizados.textOpcion = textOpcion;
      if (multimedia !== undefined) datosActualizados.multimedia = multimedia;
      if (correcta !== undefined) {
        // Cambiar el estado de correcta solo si se proporciona y si es diferente al estado actual
        datosActualizados.correcta = correctaBoolean !== opcionCuestionarioExistente.correcta ? correctaBoolean : undefined;
      }

      const opcionCuestionarioActualizada = await OpcionCuestionarioModel.updateAndDeactivateOthers(
        opcionCuestionarioId,
        datosActualizados
      );

      res.json({
        mensaje: 'Opción de cuestionario actualizada con éxito',
        opcionCuestionario: opcionCuestionarioActualizada,
      });
    } catch (error) {
      console.error('Error al actualizar la opción de cuestionario:', error);
      res.status(500).json({ mensaje: 'Error interno del servidor' });
    }
  }
  
  static async delete(req, res) {
    try {
      const opcionCuestionarioId = parseInt(req.params.opcionCuestionarioId);
      const opcionCuestionarioEliminada = await OpcionCuestionarioModel.delete(opcionCuestionarioId);

      res.json({
        mensaje: 'Opción de cuestionario eliminada con éxito',
        opcionCuestionario: opcionCuestionarioEliminada,
      });
    } catch (error) {
      console.error('Error al eliminar la opción de cuestionario:', error);
      res.status(500).json({ mensaje: 'Error interno del servidor' });
    }
  }
}



//Segunda version 

//Controller 

// opcionCuestionarioController.js
import { OpcionCuestionarioModel } from "../models/opcioncuesModel.js";

export class OpcionCuestionarioController {
  static async create(req, res) {
    try {
      const preguntaCuestionarioId = parseInt(req.params.preguntaCuestionarioId);
      const multimedia = req.file ? req.file.buffer : undefined; // Verificar si hay un nuevo archivo
      const { textOpcion, correcta } = req.body;

      // Convertir correcta a booleano
      const correctaBoolean = correcta === "true";

      const opcionCuestionario = await OpcionCuestionarioModel.create(
        preguntaCuestionarioId,
        textOpcion,
        multimedia,
        correctaBoolean
      );

      res.json({
        mensaje: 'Opción de cuestionario creada con éxito',
        opcionCuestionario,
      });
    } catch (error) {
      console.error('Error al crear la opción de cuestionario:', error);
      res.status(500).json({ mensaje: 'Error interno del servidor' });
    }
  }

  static async getById(req, res) {
    try {
      const opcionCuestionarioId = parseInt(req.params.opcionCuestionarioId);
      const opcionCuestionario = await OpcionCuestionarioModel.getById(opcionCuestionarioId);
      res.json(opcionCuestionario);
    } catch (error) {
      console.error('Error al obtener la opción de cuestionario:', error);
      res.status(500).json({ mensaje: 'Error interno del servidor' });
    }
  }

  static async update(req, res) {
    try {
      const opcionCuestionarioId = parseInt(req.params.opcionCuestionarioId);
      const { textOpcion, correcta } = req.body;
      const multimedia = req.file ? req.file.buffer : undefined;

      // Convertir correcta a booleano
      const correctaBoolean = correcta === "true";

      // Obtener la opción de cuestionario antes de la actualización
      const opcionCuestionarioExistente = await OpcionCuestionarioModel.getById(opcionCuestionarioId);

      // Construir un objeto con los campos proporcionados
      const datosActualizados = {};
      if (textOpcion !== undefined) datosActualizados.textOpcion = textOpcion;
      if (multimedia !== undefined) datosActualizados.multimedia = multimedia;
      if (correcta !== undefined) {
        // Cambiar el estado de correcta solo si se proporciona y si es diferente al estado actual
        datosActualizados.correcta = correctaBoolean !== opcionCuestionarioExistente.correcta ? correctaBoolean : undefined;
      }

      const opcionCuestionarioActualizada = await OpcionCuestionarioModel.updateAndDeactivateOthers(
        opcionCuestionarioId,
        datosActualizados
      );

      res.json({
        mensaje: 'Opción de cuestionario actualizada con éxito',
        opcionCuestionario: opcionCuestionarioActualizada,
      });
    } catch (error) {
      console.error('Error al actualizar la opción de cuestionario:', error);
      res.status(500).json({ mensaje: 'Error interno del servidor' });
    }
  }

  static async delete(req, res) {
    try {
      const opcionCuestionarioId = parseInt(req.params.opcionCuestionarioId);
      const opcionCuestionarioEliminada = await OpcionCuestionarioModel.delete(opcionCuestionarioId);

      res.json({
        mensaje: 'Opción de cuestionario eliminada con éxito',
        opcionCuestionario: opcionCuestionarioEliminada,
      });
    } catch (error) {
      console.error('Error al eliminar la opción de cuestionario:', error);
      res.status(500).json({ mensaje: 'Error interno del servidor' });
    }
  }
}




// opcionCuestionarioModel.js
import { prisma } from "../conexion.js";

export class OpcionCuestionarioModel {
  // Crear Opción de Cuestionario
  static create = async (preguntaCuestionarioId, textOpcion, multimedia, correcta) => {
    const opcionCuestionario = await prisma.opcionCuestionario.create({
      data: {
        preguntaCuestionarioId: preguntaCuestionarioId,
        textOpcion: textOpcion,
        multimedia: multimedia,
        correcta: correcta,
      },
      include: {
        PreguntaCuestionario: true,
      },
    });
    return opcionCuestionario;
  };
  

  // Obtener Opción de Cuestionario por ID
  static getById = async (opcionCuestionarioId) => {
    const opcionCuestionario = await prisma.opcionCuestionario.findUnique({
      where: { id: opcionCuestionarioId },
      include: {
        PreguntaCuestionario: true,
      },
    });
    return opcionCuestionario;
  };

  // Actualizar Opción de Cuestionario
  static update = async (opcionCuestionarioId, nuevaInformacion) => {
    const opcionCuestionarioActualizada = await prisma.opcionCuestionario.update({
      where: { id: opcionCuestionarioId },
      data: nuevaInformacion,
      include: {
        PreguntaCuestionario: true,
      },
    });
    return opcionCuestionarioActualizada;
  };

  // Eliminar Opción de Cuestionario por ID
  static delete = async (opcionCuestionarioId) => {
    const opcionCuestionarioEliminada = await prisma.opcionCuestionario.delete({
      where: { id: opcionCuestionarioId },
      include: {
        PreguntaCuestionario: true,
      },
    });
    return opcionCuestionarioEliminada;
  };

  // Obtener todas las opciones asociadas a una pregunta
  static getAllByPregunta = async (preguntaCuestionarioId) => {
    const opciones = await prisma.opcionCuestionario.findMany({
      where: {
        preguntaCuestionarioId: preguntaCuestionarioId,
      },
    });
    return opciones;
  };

  // Actualizar Opción de Cuestionario y desactivar otras opciones como correctas
  static updateAndDeactivateOthers = async (opcionCuestionarioId, nuevaInformacion) => {
    const opcionCuestionarioActualizada = await prisma.opcionCuestionario.update({
      where: { id: opcionCuestionarioId },
      data: nuevaInformacion,
      include: {
        PreguntaCuestionario: true,
      },
    });

    // Desactivar otras opciones como correctas
    if (nuevaInformacion.correcta) {
      await prisma.opcionCuestionario.updateMany({
        where: {
          preguntaCuestionarioId: opcionCuestionarioActualizada.PreguntaCuestionario.id,
          id: { not: opcionCuestionarioId },
        },
        data: {
          correcta: false,
        },
      });
    }

    return opcionCuestionarioActualizada;
  };
}


//
$2b$10$E4GEQPwiGuW26Hbglg.uZeI2gsUVIMVyVskKuLen/2LGzLtysvun2
$2b$10$E4GEQPwiGuW26Hbglg.uZeI2gsUVIMVyVskKuLen/2LGzLtysvun2	
$2b$10$lWNIw7UPe5xseWfJJyADbuNqhmWwP6yJd2ubsmGqVuNvi24T.xz4G	2023-12-01 04:20:11.599	1



//

const handleEnviarCodigo = async () => {
    try {
      const response = await fetch('http://localhost:3000/cambiocontrasena/solicitar', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ correo }),
      });

      const data = await response.json();

      if (response.ok) {
        setCodigoEnviado(true);
        setMensaje('Código enviado exitosamente al correo del usuario.');
        setOpenModal(true);
      } else {
        setMensaje(data.mensaje || 'Error al enviar el código.');
      }
    } catch (error) {
      console.error('Error al enviar el código:', error);
      setMensaje('Error interno del servidor.');
    }
  };

  const handleGuardarContrasena = async () => {
    try {
      const response = await fetch('http://localhost:3000/cambiocontrasena/verificar', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ correo, codigo, nuevaContrasena,confirmarContrasena }),
      });

      const result = await response.json();

      if (response.ok) {
        setMensaje('Contraseña actualizada con éxito');
        setOpenModal(false);
      } else {
        setMensaje(result.mensaje || 'Error al actualizar la contraseña.');
      }
    } catch (error) {
      console.error('Error al verificar el código y actualizar la contraseña:', error);
      setMensaje('Error interno del servidor.');
    }
  };

  const handleReenviarCodigo = async () => {
    try {
      const response = await fetch('http://localhost:3000/cambiocontrasena/reenviar', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ correo }),
      });

      const data = await response.json();

      if (response.ok) {
        setCodigoEnviado(true);
        setMensaje('Código reenviado exitosamente al correo del usuario.');
      } else {
        setMensaje(data.mensaje || 'Error al reenviar el código.');
      }
    } catch (error) {
      console.error('Error al reenviar el código:', error);
      setMensaje('Error interno del servidor.');
    }
  };



  <Grid columns={2} style={{ height: '104vh' }}>
        <Grid.Row>
          <Grid.Column style={{ background: '#E0DCDC' }} stretched>
            <Image src={imagen} alt="Imagen" />
          </Grid.Column>
          <Grid.Column>
            <Grid.Row>
              <Header as='h1' style={{ margin: '5% 0 0 5%' }}> Bienvenido a Math Learn Lab</Header>
              <Header as='h1' style={{ margin: '0 0 10% 10%' }}> Restablecer Contraseña</Header>
            </Grid.Row>
            <Grid.Row>
              <Form>
                <Form.Field>
                  <label>Correo Electrónico</label>
                  <input
                    type="email"
                    placeholder="Correo Electrónico"
                    value={correo}
                    onChange={(e) => setCorreo(e.target.value)}
                  />
                </Form.Field>

                <Button onClick={handleEnviarCodigo} type='button' fluid animated>
                  <Button.Content visible>Enviar Código</Button.Content>
                  <Button.Content hidden>
                    <Icon name='arrow right' />
                  </Button.Content>
                </Button>

                {mensaje && (
                  <Message positive={codigoEnviado} negative={!codigoEnviado}>
                    <Message.Header>{mensaje}</Message.Header>
                  </Message>
                )}
              </Form>
            </Grid.Row>
            <Grid.Row>
              <Segment style={{ margin: "0 10% 0 10%" }} basic textAlign='center'>
                <Link to="/InicioSesion">
                  <Header as='h4' content="Iniciar Sesion" />
                </Link>
                <Divider horizontal> o </Divider>
                <Link to="/">
                  <Header as='h4' content="Regresar a Inicio" />
                </Link>
              </Segment>
            </Grid.Row>
          </Grid.Column>
        </Grid.Row>
      </Grid>